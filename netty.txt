nio
 buffer 写入 读出 需要flip 用完 clear
  服务端 1创建    Selector selector = Selector.open();
         2创建  ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
		 3绑定     InetSocketAddress inetSocketAddress = new InetSocketAddress(6667);
        serverSocketChannel.socket().bind(inetSocketAddress);
        serverSocketChannel.configureBlocking(Boolean.FALSE);
		  4 注册  serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
		  5 读取 写入 
		      while (true) {
            int select = selector.select();
            if (select > 0) {
                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()){
                    SelectionKey v = iterator.next();
                    try {
                        if (v.isAcceptable()) {
                            SocketChannel accept = serverSocketChannel.accept();
                            accept.configureBlocking(Boolean.FALSE);
                            accept.register(selector, SelectionKey.OP_READ);
                            System.out.println(accept.getRemoteAddress() + " 上线");
                        }
                        if (v.isReadable()) {
                            SocketChannel channel = (SocketChannel) v.channel();
                            ByteBuffer byteBuffer = ByteBuffer.allocate(10240);
                            channel.read(byteBuffer);
                            byteBuffer.flip();
                            System.out.println(new String(byteBuffer.array()));
                            System.out.println("connect");
                            byteBuffer.clear();
                            byteBuffer.putChar('h');
                            byteBuffer.putChar('e');
                            byteBuffer.flip();
                            channel.write(byteBuffer);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    iterator.remove();
                }
            }
 
 客户端 1 创建    Selector selector = Selector.open();
        2 创建 注意是 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1",8888));
		3注册       socketChannel.register(selector, SelectionKey.OP_READ);
		4 读取     new Thread(
                ()->{
                    while (true){
                       try{
                           int select = selector.select();
                           if(select>0){
                               Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                               while (iterator.hasNext()){
                                   SelectionKey next = iterator.next();
                                   if(next.isReadable()){
                                       System.out.println("read");
                                       SocketChannel channel = (SocketChannel) next.channel();
                                       ByteBuffer bytereadBuffer = ByteBuffer.allocate(10240);
                                       channel.read(bytereadBuffer);
                                       System.out.println("----------"+new String(bytereadBuffer.array()));
                                       bytereadBuffer.clear();
                                       ByteBuffer byteBuffer = ByteBuffer.wrap(new String("test is tes").getBytes());
                                       SocketChannel writesocketChannel = (SocketChannel) next.channel();
                                       writesocketChannel.write(byteBuffer);
                                       byteBuffer.clear();
                                   }
                                   iterator.remove();
                               }
                           }
                       }catch (Exception e){

                       }
                    }
                }
        ).start();
		
		
netty
     服务端   1 创建 workgroup bootgroup
	          EventLoopGroup bootGroup = new NioEventLoopGroup();
              EventLoopGroup workGroup = new NioEventLoopGroup();
	          2 创建 serverbootstrap       ServerBootstrap bootstrap = new ServerBootstrap();
			  3 处理 绑定
			   bootstrap.group(bootGroup,workGroup)
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 128)//设置线程队列 连接个数
                .childOption(ChannelOption.SO_KEEPALIVE, true)//设置保持活动连接状态
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel sc) throws Exception {
                        sc.pipeline().addLast(new StringDecoder());
                        sc.pipeline().addLast(new StringEncoder());
                        sc.pipeline().addLast(new ServerHandler());
                    }
                });
				4 启动        ChannelFuture future = bootstrap.bind(8888).sync();
				
	  客户端 1创建 workagroup
	             EventLoopGroup clientgroup = new NioEventLoopGroup();
		     2 创建 bootstrap 注意和server端不一样        Bootstrap clientBoot = new Bootstrap();
			 3 绑定    clientBoot
                .group(clientgroup)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel sc) throws Exception {
                        sc.pipeline().addLast(new StringDecoder());
                        sc.pipeline().addLast(new StringEncoder());
                        sc.pipeline().addLast(clientHandler);
                    }
                });
				4 绑定
			  ChannelFuture future = clientBoot.connect("127.0.0.1", 8888).sync();
		处理流处理
		public class ClientHandler extends ChannelInboundHandlerAdapter {

    private ChannelHandlerContext context;

    private Object result;

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        this.context = ctx;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        result=msg.toString();
        System.out.println("return********"+result);
        ctx.flush();
    }

    public Object getbean(Class proxyclass) {
        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{proxyclass}, (proxy, method, args) -> {
            context.writeAndFlush(proxyclass.getName()+"#"+method.getName()+"#"+args[0]);
            return result;
        });
    }
}
		
